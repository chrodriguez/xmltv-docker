#!/usr/local/bin/perl -w

eval 'exec /usr/local/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell

eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell

=pod

=head1 NAME

tv_grab_ar - Grab TV listings for Argentina.

=head1 SYNOPSIS

tv_grab_ar --help

tv_grab_ar [--config-file FILE] --configure [--gui OPTION]

tv_grab_ar [--config-file FILE] [--output FILE] [--days N]
           [--offset N] [--quiet] [--GetDetails]

tv_grab_ar --list-channels

tv_grab_ar --capabilities

tv_grab_ar --version

=head1 DESCRIPTION

Output TV listings for several channels available in Argentina.
Now supports the terrestrial analog tv listings, which is the most common tv 
viewed in Argentina. 
The tv listings comes from http://www.buscadorcablevision.com.ar/
The grabber relies on parsing HTML so it might stop working at any time.

First run B<tv_grab_ar --configure> to choose, which channels you want
to download. Then running B<tv_grab_ar> with no arguments will output
listings in XML format to standard output.

B<--configure> Prompt for which channels,
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_ar.conf>.  This is the file written by
B<--configure> and read when grabbing.

B<--gui OPTION> Use this option to enable a graphical interface to be used.
OPTION may be 'Tk', or left blank for the best available choice.
Additional allowed values of OPTION are 'Term' for normal terminal output
(default) and 'TermNoProgressBar' to disable the use of XMLTV::ProgressBar.

B<--output FILE> Write to FILE rather than standard output.

B<--days N> Grab N days.  The default is 3.

B<--offset N> Start N days in the future.  The default is to start
from today.

B<--quiet> Suppress the progress messages normally written to standard
error.

B<--capabilities> Show which capabilities the grabber supports. For more
information, see L<http://wiki.xmltv.org/index.php/XmltvCapabilities>

B<--version> Show the version of the grabber.

B<--help> Print a help message and exit.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR
1.14 Mariano S. Cosentino, 4xmltv@marianok.com.ar
1.13 Mariano S. Cosentino, 4xmltv@marianok.com.ar
1.12 rmeden
1.10 Mariano S. Cosentino, Mok@marianok.com.ar
1.9 Mariano S. Cosentino, Mok@marianok.com.ar
1.8 rmeden
1.7 Mariano S. Cosentino, Mok@marianok.com.ar
1.6 Mariano S. Cosentino, Mok@marianok.com.ar
1.5 Christian A. Rodriguez, car@cespi.unlp.edu.ar, based on tv_grab_es, from Ramon Roca.

=head1 BUGS

This grabber extracts all information from cablevision website. Any change in this
web page may cause this grabber to stop working.
Retrieving the description information adds a considerable amount of time to the run and makes the file quite large.
migth be a good idea to add a cache file the keeps the program description so there is no need to fetch it.

=cut



# Author's Updates
#   1.15   honir
#     *    Re-aply patch 1.12 which was inadvertently overwritten by 1.13
#   1.14   honir
#     *    Major modification to use new website structure
#   1.14 ?        Mariano Cosentino
#               *       added function to handle character conversion to utf-8
#   1.13        Mariano Cosentino
#               *       solved issue with descriptions
#   1.12        rmeden
#               apply Karl's patches to remove switch statements
#   1.10 	Mariano Cosentino
#		* 	fixed prototype warning
#		* 	Removed default value for location, as the old channel ids are no compatible with the site's new format.
#   1.9 	Mariano Cosentino
#		* 	The source website changed, I've adapted the script to the new format
#		*	Additional information is now handled directly here, no need for most of tv_extractinfo_ar
#		*	Added support for locations. 
#		*	*	Added parameter --zone for Zone ovewride w/o running full config
#		*	*	TELECENTRO is handled as a zone.
#		*	*	DirectTV is handled as a zone. *** in any case, if you have DTV, you should be using TV_GRAB_DTV_LA instead of this grabber :-) ***
#		*	*	All other Zones are extracted automatically from the CV website and all this zones have Cablevision's programming (not Telecentro, no DTV)
#		*	*	The "default" Zone is still Capital Federal / Gran Buenos Aires (Cablevision zone 3)
#		*	*	This is still to be tested by people outside GBA to see if is acurate. 
#		*	*	This is based on the work of Mauro Meloni and his Phyton version of TV_GRAB_AR http://mauromeloni.com.ar/files/tv_grab_ar.py.
#		*	Added parameter --getdetails to allow the user to control if they want the full details (time consuming) *** I should probably put it in the config section ***
#		* 	While it's working fine, this version still has a lot of room to improvements. I decided to release a quick-and-dirty version in order to have it up and running and then I wil work on the enhacements.
#		*	Some additional error handling should avoid fatal failures when the Cablevision  website becomes unresponsive (far too often for my taste).
#   1.8		rmeden
#		apply dekarl's patch 3057655 to update lots of xmltv.org links
#   1.7 	Mariano Cosentino
#		* 	The source website changed, I've adapted the script to the new format
#		*	Enhaced the handling of latin chars.
#		*	Added control and cache to avoid downloading the same program data multiple times in the same session.
#   1.6 	Mariano Cosentino
#		* 	Added descriptions support
#		*	All properties (director, autor, etc) are appended to the description for added value
#		*	All times are now UTC as per XMLTV recomendations
#		*	Cablevision and Multicanal use the same format (both are the same company now) so added variable to customize where to grab the listings from.



# Author's TODOs & thoughts
#
# Add channel logo support (download from $urlRoot/logos/lg_99.png where 99 is the channel id)
# Add Support for Argentinean DST
# add properties in the corresponding XMLTV fields without relying on the tv_extractinfo_ar (partialy done)
# migth be a good idea to add a cache file the keeps the program description so there is no need to fetch it.


my $CableCompany = "cablevisionfibertel";    # "cablevision"; #"multicanal";
my $urlRoot="http://www.buscador." . $CableCompany . ".com.ar/";


######################################################################
# initializations

use strict;
use XMLTV::Version '$Id: tv_grab_ar,v 1.19 2014/10/19 17:18:40 bilbo_uk Exp $ ';
use XMLTV::Capabilities qw/baseline manualconfig cache/;
use XMLTV::Description 'Argentina';
use Getopt::Long;
use Date::Manip;
use HTML::TreeBuilder;
use HTML::Entities; # parse entities
use IO::File;

use Encode qw(from_to is_utf8 _utf8_off encode decode);
use utf8;

use HTTP::Cookies;
use LWP::UserAgent;
my $lwp = &initialise_ua();

use JSON::PP;

use XMLTV;
use XMLTV::Memoize;
use XMLTV::ProgressBar;
use XMLTV::Ask;
use XMLTV::Config_file;
use XMLTV::DST;
# So we are not affected by winter/summer timezone
$XMLTV::DST::Mode='none';

#use XMLTV::TZ 'UTC'; # qw(parse_local_date);
Date_Init('TZ=UTC');
use XMLTV::Get_nice;
use XMLTV::Mode;
use XMLTV::Date;


sub select_location();




# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
$0: get Argentinian television listings in XMLTV format
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
        [--offset N] [--quiet] [--getdetails] [--zone N]
To list channels: $0 --list-channels
To show capabilities: $0 --capabilities
To show version: $0 --version
END
  ;
# We don't need random delays
$XMLTV::Get_nice::Delay=0;

# Attributes of the root element in output.
my $HEAD = { 'source-info-url'     => $urlRoot,
	     'source-data-url'     => $urlRoot,
	     'generator-info-name' => 'XMLTV',
	     'generator-info-url'  => 'http://xmltv.org/',
	   };
		   
# default language
my $LANG="es";

# Selected location
our %location;

# Global channel_data
our @ch_all;

# Global ProgID/Description Hash
my %Descriptions = ();

# Overlaping time threshold allowed in seconds
our $allowed_overlap_tresh=180;


my %channels;
my @channels;

######################################################################
# get options

# Get options, including undocumented --cache option.
XMLTV::Memoize::check_argv('XMLTV::Get_nice::get_nice_aux');
my ($opt_days, $opt_offset, $opt_help, $opt_output,
    $opt_configure, $opt_config_file, $opt_gui,
    $opt_quiet, $opt_get_details, $opt_zone, $opt_list_channels);
$opt_days  = 3; # default
$opt_offset = 0; # default
$opt_quiet  = 0; # default
$opt_zone = 0; # default for 
$opt_get_details = 0; # default

GetOptions('days=i'        => \$opt_days,
	   'offset=i'      => \$opt_offset,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
       'gui:s'         => \$opt_gui,
	   'output=s'      => \$opt_output,
	   'quiet'         => \$opt_quiet,
	   'getdetails'	   => \$opt_get_details,
	   'zone=i'        => \$opt_zone,
	   'list-channels' => \$opt_list_channels
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
usage(1) if $opt_help;

XMLTV::Ask::init($opt_gui);

my $mode = XMLTV::Mode::mode('grab', # default
			     $opt_configure => 'configure',
			     $opt_list_channels => 'list-channels',
			    );

# File that stores which channels to download.
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_ar', $opt_quiet);

my @config_lines; # used only in grab mode
if ($mode eq 'configure') {
    XMLTV::Config_file::check_no_overwrite($config_file);
}
elsif ($mode eq 'grab') {
    @config_lines = XMLTV::Config_file::read_lines($config_file);
}
elsif ($mode eq 'list-channels') {
    @config_lines = XMLTV::Config_file::read_lines($config_file);
}
else { die }

if (($opt_zone != 0) && ($mode ne 'configure')) {
	warn "Zone overwride by user, using zone $opt_zone\n";
	%location = (
		id => $opt_zone,
		name => 'USER SELECTED LOCATION'
			);
}
######################################################################
# write configurationDateCalc(


if ($mode eq 'configure') {
    open(CONF, ">$config_file") or die "cannot write to $config_file: $!";

    %location = select_location();
    print CONF "location $location{id} $location{name}\n";

    # we need the channels data.
    %channels = get_channels(); # sets @ch_all

    # Ask about each channel.
    my @chs = sort keys %channels;
    my @names = map { $channels{$_} } @chs;
    my @qs = map { "add channel $_?" } @names;
    my @want = ask_many_boolean(1, @qs);
    foreach (@chs) {
        my $w = shift @want;
        warn("cannot read input, stopping channel questions"), last
          if not defined $w;
        # No need to print to user - XMLTV::Ask is verbose enough.

        # Print a config line, but comment it out if channel not wanted.
        print CONF '#' if not $w;
        my $name = shift @names;
        print CONF "channel $_ $name\n";
        # TODO don't store display-name in config file.
    }

    close CONF or warn "cannot close $config_file: $!";
    say("Finished configuration.");

    exit();
}


# Not configuration, we must be writing something, either full
# listings or just channels.
#
die if $mode ne 'grab' and $mode ne 'list-channels';

# Options to be used for XMLTV::Writer.
my %w_args;
if (defined $opt_output) {
    my $fh = new IO::File(">$opt_output");
    die "cannot write to $opt_output: $!" if not defined $fh;
    $w_args{OUTPUT} = $fh;
}
$w_args{encoding} = 'ISO-8859-15';
my $writer = new XMLTV::Writer(%w_args);
$writer->start($HEAD);


######################################################################
# Read configuration
my $line_num = 1;
foreach (@config_lines) {
    ++ $line_num;
    next if not defined;

    if (/^location:?\s+(\S+)\s+([^\#]+)/) {
        %location=( id => $1, name=>$2 );
    }else{
        die "No location specified, run me with --configure\n"
          if not keys %location;
    
    #    if (/^channel:?\s+(\S+)\s+(\S+)\s+([^\#]+)/) {
    if (/^channel:?\s+(\S+)\s+([^\#]+)/) {
      my $ch_did = $1;
      #    my $ch_sourceid = $2;
      my $ch_name = $2;
      $ch_name =~ s/\s*$//;
      push @channels, $ch_did;
      $channels{$ch_did} = $ch_name;
    } else {
      warn "$config_file:$line_num: bad line\n";
    }
  }
}


######################################################################
if ($mode eq 'list-channels') {
    # we need the channels data.
    %channels = get_channels(); # sets @ch_all
		
		foreach (@ch_all) {
			#channel' writer only accepts id, display-name, url, icon
			delete $_->{'channel-id'};
			delete $_->{'channel-num'};
			$writer->write_channel($_);
		}
    $writer->end();
    exit();
}


######################################################################
# We are producing full listings.
die if $mode ne 'grab';


# we need the channels data.  (oh no we don't!)
#%channels = get_channels(); # sets @ch_all


######################################################################
# begin main program

# Assume the listings source uses ARG TIME (see BUGS above).
my $now = DateCalc(parse_date('now'), "$opt_offset days");

die "No channels specified, run me with --configure\n"
  if not keys %channels;

die "No location specified, run me with --configure\n"
  if not keys %location;

die "No channels selected, run me with --configure\n"
  if (scalar @channels == 0);


#if (not keys %location) {
#	warn "No location specified, will use 'Capital Federal -GBA' by default. If you wish a diferent one run me with --configure\n" ;
#	%location = (
#			id => 3,
#			name => 'Capital Federal -GBA'
#		);
#}
my @to_get;

# print the <channel> info
foreach my $ch_did (@channels) {
    my $index=0;
    my $ch_name=$channels{$ch_did};
    my $ch_xid="$ch_did.cablevision";
		
    #       my $tot_ch=@ch_all;
    #       while (($tot_ch > $index) and (${$ch_all[$index]}{'id'} ne $ch_xid)) {
    #           $index=$index+1;
    #       }
    #       next if ($tot_ch <= $index);
		#      		
    #       my $ch_num=${ch_all[$index]}{'channel-num'};
    #       $writer->write_channel({ id => $ch_xid,
		#       	     'display-name' => [ [ $ch_name ],
		#       				 [ $ch_num ] ] });			 
    #       my $day=UnixDate($now,'%Q');
    #       for (my $i=0;$i<$opt_days;$i++) {
    #           push @to_get, [ $day, $ch_did, $ch_num ];
    #           #for each day
    #           $day=nextday($day); die if not defined $day;
    #       }
		
    $writer->write_channel({ 'id' => $ch_xid,
                             'display-name' => [ [ $ch_name ] ] });
}

# progress bar
my $bar = new XMLTV::ProgressBar('getting listings', $opt_days)
  if not $opt_quiet;
	
# fetch and print the <programme> info
for (my $i = $opt_offset; $i < $opt_offset + $opt_days; $i++) {

	# the ajax fetches 6 stations at a time, so we'll emulate that
	my $numtoprocess = 6;
	for ( my $j=0; $j < scalar @channels; $j+=$numtoprocess ) {

		# array slice returns 'undef' for values oustide the array
		my @slice = @channels[$j..$j+$numtoprocess-1];
		my $schedule = process_table( $i, \@slice );   # $i is the day number (0...) to fetch
		foreach my $c ( keys %{$schedule} ) {
			foreach my $t ( keys %{$schedule->{$c}} ) {
				$writer->write_programme( $schedule->{$c}->{$t} );
			}
		}
	}

	update $bar if not $opt_quiet;
}

$bar->finish() if not $opt_quiet;
$writer->end();

######################################################################
# subroutine definitions

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
#	\&Log::TraceMessages::Logfile = 'tv_grab_ar.log';
#	Log::TraceMessages::Logfile = 'tv_grab_ar.log';
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

####
# process_table: fetch a URL and process it
#
# arguments:
#    Date::Manip object giving the day to grab
#    xmltv id of channel
#    id of channel from cablevision
#
# returns: list of the programme hashes to write
#
sub process_table {
    my ($day, $chanstoprocess) = @_;
		
    # Get the programme schedule for the selected channels for the param day
		my %r;
		
		# First we need the container for the Location 
    #   https://buscador.cablevisionfibertel.com.ar/index.aspx?cl=136
		#	  http://www.buscador.cablevisionfibertel.com.ar/index.aspx?dia=1&hora=1
    #   
		my $url = $urlRoot.'index.aspx?int=1&cl='.$location{'id'}.'&dia='.$day;
    my $page = fetch_url($url);  
    die $page if $page =~ /^Status:/;  
    #store_page($page);
    my $tree = get_tree($page); $page = undef;
		
		# Now we need to emulate the AJAX call for the grid
		#
		#   "/TVGridWS/TvGridWS.asmx/ReloadGrid"
		#    "{"daySel":"0","clasDigId":"136","signalsIdsReceived":"343,3,192,709,477,62|2,3,4,5,6,7","digHd":1}" 
		#    
		#         function pageLoad() {
    #            blackin();
    #            var elementAux1 = document.getElementById('ContGral_digClasId');
    #            var elementAux2 = document.getElementById('ContGral_daySelected');
		#    
    #            TVGridWS.ReloadGrid(elementAux2.value, elementAux1.value, idsSignalText1 + "|" + sintoniaSignal, (digHd.value != "true") ? 1 : 2, onSuccessFirst);
    #        }
		#    
		#    <input type="hidden" name="ctl00$ContGral$digClasId" id="ContGral_digClasId" value="136" />
    #    <input type="hidden" name="ctl00$ContGral$digHd" id="ContGral_digHd" value="false" />
    #    <input type="hidden" name="ctl00$ContGral$daySelected" id="ContGral_daySelected" value="0" />
		#    
		$url = $urlRoot.'TVGridWS/TvGridWS.asmx/ReloadGrid';
    my $clasDigId = $tree->look_down( '_tag' => 'input', 'id' => 'digClasId' )->attr('value');
    my $daySel = $tree->look_down( '_tag' => 'input', 'id' => 'daySelected' )->attr('value');
    my $digHd = $tree->look_down( '_tag' => 'input', 'id' => 'digHd' )->attr('value') ne 'true' ? 1 : 2;
		my $idsSignalText1 = $tree->look_down( '_tag' => 'input', 'id' => 'idsChanels' )->attr('value');
		my $sintoniaSignal = $tree->look_down( '_tag' => 'input', 'id' => 'sintoniaChanels' )->attr('value');

    #	   <input type="hidden" name="ctl00$ContGral$idsChanels" id="ContGral_idsChanels" 
 		#         value="772,192,477,96,175,35,36,6,292,40,229,18,223,84,153,978,136,226,76,2292,77,45,33,15,37,22,19,366,11,164,17,178,9,57" />
		#    <input type="hidden" name="ctl00$ContGral$sintoniaChanels" id="ContGral_sintoniaChanels"
    #         value="7,8,9,10,11,12,13,14,15,16,17,18,19,20,20,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38" />
		
		my @webIds = split(/,/, $idsSignalText1 );
		my @tvIds = split(/,/, $sintoniaSignal );	
		my ( %webIdsHash, %tvIdsHash );
    for (my $i=0; $i<scalar @webIds; $i++) {
			$webIdsHash{$webIds[$i]} = $tvIds[$i];
			$tvIdsHash{$tvIds[$i]} = $webIds[$i];
		}
		my ($idsSignalText1_1, $sintoniaSignal_1) = ('','');
		foreach (@{$chanstoprocess}) {
			next if !defined $_;  # see the @channels array slice above
			$sintoniaSignal_1 .= ($sintoniaSignal_1 ne '' ? ',' : '') . $_;
			$idsSignalText1_1 .= ($idsSignalText1_1 ne '' ? ',' : '') . $tvIdsHash{$_};
		}
		
		# 2014-10-19 site now only returns a 4 hour window
		for (my $i = 1; $i <= 7; $i++) {
		
			my $vars = [ "daySel"=>$daySel, "clasDigId"=>$clasDigId, "signalsIdsReceived"=>$idsSignalText1_1.'|'.$sintoniaSignal_1, "digHd"=>$digHd, "hourSel"=>$i, "sitio"=>"" ];
			#use Data::Dumper; print STDERR Dumper($vars);
			$page = fetch_url($url, 'post', $vars); 
			die $page if $page =~ /^Status:/;  	 
			#store_page($page);
			
			use XML::Parser;
			my $xml = XML::Parser->new(Style => 'Tree')->parse($page);
			my $html = $xml->[1]->[2];
			#print Dumper($html);
			my $res_tree = HTML::TreeBuilder->new_from_content($html);
			#print Dumper($res_tree);
			undef $xml; undef $html;
			
			
			my @progs = $res_tree->look_down( '_tag' => 'div', 'class' => 'programa' );
			die 'no programmes found' if !scalar @progs;
			#print Dumper(@progs);
			#print STDERR "\nprogs found ".scalar @progs."\n";
			

			foreach my $cur (@progs) {
				my $p = make_programme_hash($cur, \%webIdsHash, \%tvIdsHash);
				next if (defined $p && $p eq 'false');
				if (not $p) {
						require Data::Dumper;
						my $d = Data::Dumper::Dumper($cur);
						warn "cannot write programme on day $day:\n$d\n";
				}
				
				else {
						$r{ $p->{'channel'} }{ $p->{'start'} } = $p;		# prevent duplicates
				}
			}
		
		}

		return \%r;
}

# Hashes the program for future saving in XMLTV format
sub make_programme_hash {
    my ( $prog, $webIds, $tvIds ) = @_;
		
			#  <div id="accordion38201" class="programa" style="width:204px;left:2244px">
			#    <span class="title" onmouseover="pintarCanal(343);" onmouseout="despintarCanal();">Noticias y consumidores</span>
			#  	<div id="programaInterno" class="programaInterno" style="display: none;">
			#  	  <span class="category">Noticias</span>
			#  		<span class="dataProgram">Argentina  |  Con Susana Andrada, Myriam Bunin</span>
			#  		<div class="diaGrilla">Hoy martes 10 de diciembre 11:00:00Hs</div>
			#  		<img class="chapaParentalProgram" src="images/parental/PG.png" alt="Se recomienda orientación parental" title="Se recomienda orientación parental">
			#  		<div class="duracionGrilla">Duración: 60min</div>
			#  		<a rel="#overlay_ficha" href="FichaContent.aspx?id=38201&amp;idSig=343" class="masinfoGrid"></a>
			#  	</div>
			#  </div>
			
			# <div id="accordion27254" class="programa" style="width:102px;left:1836px">
			#   <span class="title" onmouseover="pintarCanal(178);" onmouseout="despintarCanal();">Boys Toys<br>
			#      <span class="titleSeason">Temporada: 3</span>
			#      <span class="titleChapter">Episodio: 311</span>
			#   </span>
			#   <div id="programaInterno" class="programaInterno" style="display: none;">
			#      <span class="category">Variedades</span>
			#      <span class="dataProgram">2013 </span>
			#      <span class="sinopsisShort">Los juguetes más innovadores del siglo XXI. Recorremos el mundo para traerte los mejores aparatos técnicos, productos súper exclusivos y vehículos ultra poderosos. Prepárate para experimentar lo último en juguetes tecnológicos.</span>
			#      <div class="diaGrilla">Hoy viernes 13 de diciembre 09:00:00Hs</div>
			#      <img class="chapaParentalProgram" src="images/parental/NR.png" alt="No clasificada" title="No clasificada">
			#      <div class="duracionGrilla">Duración: 30min</div>
			#      <a rel="#overlay_ficha" href="FichaContent.aspx?id=27254&amp;idSig=178" class="masinfoGrid"></a>
			#   </div>
			# </div>
		
		  # As at 2014-10-19:
			#	<div id="accordion33892" class="programa" style="width: 204px; left: 2652px; height: 50px; display: block; ">
			#		<div id="programaInterno" class="programaInterno" style="display: none; "></div>
			#		<div class="title" onmouseover="pintarCanal(292);" onmouseout="despintarCanal();" style="">
			#			<span>Visión 7 - Mediodía</span><br>
			#		</div>
			#	</div>
			#
			# Programme details needs a separate ajax call ! (sheesh these JS programmers crack me up; just because you *can* do something via ajax doesn't mean 
			#                                                                   to say you *should* - technology gone mad!)
			# 		
      #        <img class="imgAcordeon" src="https://buscador.cablevisionfibertel.com.ar/imagesFilms/charlie_and_the_chocolate_factory1.jpg_h.jpg" />	
			#			<div class="contenedorDatosAcordeon">
			#				<span class="category">Noticias</span>
			#				<span class="dataProgram">Argentina  Con Agustina Díaz, Roberto Gómez Ragozza</span>
			#				<span class="sinopsisShort">El noticiero de la TV Pública refleja la actualidad desde una visión federal y latinoamericana, que defiende el interés 
			#                   comunitario. Visión Siete es sinónimo de noticias para todos.</span>
			#				<div class="diaGrilla">lunes 20 de octubre | 13:00:00Hs | Duración: 60min</div>
			#				<a alt="Mas info" title="Mas info" rel="#overlay_ficha" href="FichaContent.aspx?id=33892&amp;idSig=292" class="masinfoGrid"></a>
			#				<a alt="Agendar en Gmail" title="Agendar en Gmail" href="https://www.google.com/calendar/render?action=TEMPLATE&amp;text=Ver Visión 7 -  
			#                   Mediodía&amp;dates=20141020T160000Z/20141020T170000Z&amp;details=El noticiero de la TV Pública refleja la actualidad desde una visión federal 
			#                   y latinoamericana, que defiende el interés comunitario. Visión Siete es sinónimo de noticias para todos.&amp;sf=true&amp;output=xml" 
			#                   target="_blank" class="agendar"></a>
			#				<a alt="Compartir en Facebook" title="Compartir en Facebook" target="_blank" class="facebook" 
			#                   href="http://www.facebook.com/sharer.php?s=100&amp;p[url]=http%3A//clientes.cablevisionfibertel.com.ar%2fBuscador"></a>
			#				<a alt="Compartir en Twitter" title="Compartir en Twitter" target="_blank" 
			#                   href="https://twitter.com/share?url=https://clientes.cablevisionfibertel.com.ar/Buscador&amp;text=&amp;count=none" class="twitter" 
			#                   data-lang="es"></a>
			#			</div>
			#
		
		my $cur;
		my %temp;
		$temp{'title'} = $prog->look_down( '_tag' => 'div', 'class' => 'title' );
		if (!defined $temp{'title'}) {			# empty div... try span
			$temp{'title'} = $prog->look_down( '_tag' => 'span', 'class' => 'title' );
			if (!defined $temp{'title'}) {			# empty span
				return 'false';
			}
		}
				
		my $url = $urlRoot.'TVGridWS/TvGridWS.asmx/GetProgramDataAcordeon';
    my $idSignal = $prog->parent->attr('idsignal');
    my $idEvent = $prog->attr('id');
    $idEvent =~ s/accordion//;
		
		my $vars = [ "idEvent"=>$idEvent, "idSignal"=>$idSignal, "sitio"=>"" ];
		#use Data::Dumper; print STDERR Dumper($vars);
    my $page = fetch_url($url, 'post', $vars); 
    die $page if $page =~ /^Status:/;  	 
    #store_page($page);
		
		use XML::Parser;
		my $xml = XML::Parser->new(Style => 'Tree')->parse($page);
		my $html = $xml->[1]->[2];
		#print Dumper($html);
		my $res_tree = HTML::TreeBuilder->new_from_content($html);
		#print Dumper($res_tree);
		undef $xml; undef $html;		
		
		$temp{'ch'} = $temp{'title'}->attr('onmouseover');
		$temp{'series'} = $temp{'title'}->look_down( '_tag' => 'span', 'class' => 'titleSeason' );
		$temp{'episode'} = $temp{'title'}->look_down( '_tag' => 'span', 'class' => 'titleChapter' );
		
		$temp{'start'} = $res_tree->look_down( '_tag' => 'div', 'class' => 'diaGrilla' );
		$temp{'duration'} = $res_tree->look_down( '_tag' => 'div', 'class' => 'duracionGrilla' );
		$temp{'data'} = $res_tree->look_down( '_tag' => 'span', 'class' => 'dataProgram' );
		$temp{'desc'} = $res_tree->look_down( '_tag' => 'span', 'class' => 'sinopsisShort' );
		$temp{'category'} = $res_tree->look_down( '_tag' => 'span', 'class' => 'category' );
		$temp{'rating'} = $res_tree->look_down( '_tag' => 'img', 'class' => 'chapaParentalProgram' );
		
		$cur->{'title'} = $temp{'title'}->as_text;
		if ($temp{'duration'}) { 		# pre 2014-10-19 format just in case!
			$cur->{'start'} = $temp{'start'}->as_text;
			$cur->{'duration'} = $temp{'duration'}->as_text;
		} else {
			my @s = split(/\|/, $temp{'start'}->as_text);  # e.g. "lunes 20 de octubre | 13:00:00Hs | Duración: 60min"
			if (scalar @s) {
				$cur->{'start'} = $s[0] . (defined $s[1] ? ' '.$s[1] : '');
				$cur->{'start'} =~ s/\|//;
				$cur->{'duration'} = (defined $s[2] ? $s[2] : '');
			}  # else barf
		}
		$cur->{'desc'} = $temp{'desc'}->as_text if $temp{'desc'};
		$cur->{'category'} = $temp{'category'}->as_text if $temp{'category'};
	
		if (defined $temp{'series'}) {
			my $seriestext = $temp{'series'}->as_text;
			$seriestext =~ s/(Temporada:|T:)\s//;
			if ($seriestext =~ /^(\d+)$/ ) {
				$cur->{'series'} = $1  if $1 ne '';
			} elsif ($seriestext ne '') {
				$cur->{'sub-title'} = $seriestext;
			}
			$temp{'series'}->detach();
		}
		
		if (defined $temp{'episode'}) {
			my $episodetext = $temp{'episode'}->as_text;
			$episodetext =~ s/(Episodio:|E:)\s//;
			if ($episodetext =~ /^(\d+)/ ) {
				$cur->{'episode'} = $1  if $1 ne '';
				if ( $episodetext =~ /^(\d+) - (.*)$/ ) { 
					$cur->{'sub-title'} = (defined $cur->{'sub-title'} ? $cur->{'sub-title'}.' : ' : '') . $2;
				}
			} elsif ($episodetext ne '') {
				$cur->{'sub-title'} = (defined $cur->{'sub-title'} ? $cur->{'sub-title'}.' : ' : '') . $episodetext;
			}
			$temp{'episode'}->detach();	
		}
		$cur->{'title'} = $temp{'title'}->as_text;		
		
		#print "$temp{'ch'} $cur->{'start'} $cur->{'title'} \n";
		
		if ( defined $temp{'data'} ) {
			my $data = $temp{'data'}->as_text;
			if ( $data =~ /^(.*?)\s?((19|20)\d\d)(\s\|\s)?(.*?)$/ ) {
				$cur->{'country'} = $1 if $1 ne '';
				$cur->{'date'} = $2 if $2 ne '';
				if ($5 ne '' && $5 ne ' ') {
					my $credits = $5;
					$credits =~ s/Con\s/,/ ;
					my @credits = split(',',$credits);
					s{^\s+|\s+$}{}g foreach @credits;	# strip leading & trailing spaces
					foreach (@credits) {
						push @{$cur->{'credits'}}, $_  if $_ ne '';
					}
					undef $credits;
				}
			}
		}
		
		if ( defined $temp{'rating'} ) {
			my $rating = $temp{'rating'}->attr('src');
			if ( $rating =~ /.*\/(.*?)\.png/ ) {		# src="images/parental/NR.png"
				$cur->{'rating'} = $1;
			}
		}
			
		if (defined $cur->{'series'} || defined $cur->{'episode'}) {
			$cur->{'episode-num'} = ( defined $cur->{'series'} && $cur->{'series'} > 0 ? $cur->{'series'} -1 : '' ) . '.' .
															( defined $cur->{'episode'} && $cur->{'episode'} > 0 ? $cur->{'episode'} -1 : '' ) . '.';
		}
		
		$temp{'ch'} =~ /pintarCanal\((\d*)\)/;
		my $ch_xmltv_id = $webIds->{$1}.'.cablevision';
		
		use Date::Language;
		my $lang = Date::Language->new('Spanish');
		# Crappy Date::Language won't parse things like 'Hoy martes 10 de diciembre 2013 11:00' !! 
		$cur->{'start'} =~ s/(Hoy|Manana)//;			
		$cur->{'start'} =~ s/:00Hs//;
		$cur->{'start'} =~ s/de//;
    $cur->{'starttime'} = $lang->str2time( $cur->{'start'} );
		# durations always seem to be in minutes (e.g. "Duración: 150min")
		my $duration;
		if ($cur->{'duration'} =~ /Duración:\s(\d*)min/ ) {
			$duration = $1;
			$cur->{'stoptime'} = $cur->{'starttime'} + ($duration * 60);
		}
		
    my %prog;
    $prog{channel}=$ch_xmltv_id;
    $prog{title}=[ [ $cur->{'title'}, $LANG ] ];
    $prog{'sub-title'}=[ [ $cur->{'sub-title'}, $LANG ] ] if defined $cur->{'sub-title'};
		$prog{'episode-num'} = [[ $cur->{'episode-num'}, 'xmltv_ns' ]] if defined $cur->{'episode-num'};
    $prog{start} = POSIX::strftime("%Y%m%d%H%M%S", gmtime( $cur->{'starttime'} )) . ' -0300';
    $prog{stop} = POSIX::strftime("%Y%m%d%H%M%S", gmtime( $cur->{'stoptime'} )) . ' -0300'  if defined $cur->{'stoptime'};
    $prog{desc}=[ [ $cur->{'desc'}, $LANG ] ] if defined $cur->{'desc'} && $cur->{'desc'} ne '';
		$prog{credits}->{'actor'} = $cur->{'credits'}  if defined $cur->{'credits'} && (scalar @{$cur->{'credits'}} > 0);
    $prog{category}=[ [ $cur->{category}, $LANG ] ] if defined $cur->{category};
    $prog{date}=$cur->{date} if defined $cur->{date};
    $prog{country}=[ [ $cur->{country}, $LANG ] ] if defined $cur->{country};
    $prog{rating}=[ [ $cur->{rating}, $LANG ] ] if defined $cur->{rating};
    return \%prog;

}

# DEPRECATED
if (0){
sub __process_table {
    my ($date, $ch_xmltv_id, $ch_ar_id) = @_;
    my $weekNr = GetWeekNumber($date);
#initial setting
#    my $url = "http://www.buscador" . $CableCompany . ".com.ar/index.php?template=fgrilla_semanal.tpl&canal=$ch_xmltv_id&semana=$weekNr";

#    my $url_head = "http://www.buscador" . $CableCompany . ".com.ar/index.php?#template=main_grilla_semanal.tpl&canal=$ch_xmltv_id&cantidadPasa=$weekNr";

    my $url_head = $urlRoot . "dinamicas/grilla_semanal/index.php?canal=$ch_xmltv_id&sintonia=$ch_ar_id&cantidadPasa=$weekNr";


#updated config
#    my $url = "http://www.buscador" . $CableCompany . ".com.ar/index.php?template=main_grilla_semanal.tpl&canal=$ch_xmltv_id&cantidadPasa=$weekNr";

    my $tree_head;

    eval {	
	 $tree_head = get_nice_tree $url_head;
	};
		
   if (not defined $tree_head) {
	warn "Unable to retrieve '$url_head'. This listing will be incomplete.";
	exit;
    } 
    my $tree=$tree_head->look_down(
        '_tag', 'div',sub {
            defined $_[0]->attr('id') and $_[0]->attr('id')=~ /grillasemanal/i
        });




    t $url_head;
    local $SIG{__WARN__} = sub {
#	my @timeData = localtime(time);
#	print join(' ', @timeData);
#        warn join(' ', @timeData) .  " $url_head: $_[0]";
        warn "$url_head: $_[0]";
    };

    # Need to disable redirects to work
    $XMLTV::Get_nice::ua->max_redirect(0);
    $XMLTV::Get_nice::ua->max_redirect(0);
    $XMLTV::Get_nice::ua->agent("");
#    $XMLTV::Get_nice::ua->user_agent("MSIE 6.0");
#    $XMLTV::Get_nice::ua->user_agent="MSIE 6.0";
    # parse the page to a document object


# The new Page holds a grid where the days are in columns and the hours are the rows
# The First days of the week is always Monday

# Variable @WeekDays will hold all programs for the week
	my @WeekDays;
#	my @Divs = $tree_head->find_by_tag_name("_tag"=>"div");

    my $tree2=$tree_head->look_down(
        '_tag', 'div',sub {
            defined $_[0]->attr('id') and $_[0]->attr('id')=~ /ContGrillaSemanal/i
        });
	my @Divs = $tree2->find_by_tag_name("_tag"=>"div");

	foreach my $elem (@Divs) {
	        my $cclass = $elem->attr('class');
        	if ((defined($cclass) && $cclass ne "") && (($cclass eq "diaSemana") || ($cclass eq "diaSemana par"))) {
        	  # @Programs =+ ($elem->find_by_tag_name("_tag"=>"a"));
		push (@WeekDays, $elem);       	           	    
		}
	}


# Variable @program_data will hold the programming for a single day
#    my @program_data = get_program_data($date,$tree,$tree_head,$ch_xmltv_id);
    my @program_data = get_program_data($date,@WeekDays);






    
    my @r;
    while (@program_data) {
        my $cur = shift @program_data;
        my $next = shift @program_data;
        unshift @program_data,$next if $next;
        my $cur_stop=ParseDate("$date $cur->{stoptime}");
        my $next_start;
        if ($next){
            $next_start=ParseDate("$date $next->{time}");
            $cur_stop=adjust_stoptime($date,$cur,$cur_stop,$next_start,$ch_xmltv_id);
        }
        if ( ($next and ( Date_Cmp($cur_stop,$next_start) <= 0 )) or !$next ){
            my $p = make_programme_hash($date, "$ch_xmltv_id.cablevision", $ch_ar_id, $cur);
            if (not $p) {
                require Data::Dumper;
                my $d = Data::Dumper::Dumper($cur);
                warn "cannot write programme on $ch_xmltv_id.cablevision on $date:\n$d\n";
            }
            else {
                push @r, $p;
            }
        }else {
                #warn "Detected duplicate programme on $ch_xmltv_id.cablevision date $date:\n\t$cur->{title} Start: $cur->{time} Ends: $cur->{stoptime} <=== Not writting\n\t$next->{title} Start: $next->{time} Ends: $next->{stoptime}\n";
        }
        $cur=undef;
        $next=undef;
    }
    @program_data=undef;
    return @r;
}
}
					
# DEPRECATED
if (0){
# Hashes the program for future saving in XMLTV format
sub __make_programme_hash {
    my ($date, $ch_xmltv_id, $ch_ar_id, $cur ) = @_;

    my %prog;
    my @tempstop;
    $prog{channel}=$ch_xmltv_id;
    $prog{title}=[ [ $cur->{title}, $LANG ] ];
    t "turning local time $cur->{time}, on date $date, into UTC";
    eval { $prog{start}=to_UTC("$date $cur->{time}", '-0300') };
    #  print "turning local time $cur->{time}, on date $date, into UTC is $prog{start}\n";
    if ($@) {
        warn "bad time string: $cur->{time}";
        return undef;
    }
    t "...got $prog{start}";
    eval { $prog{stop}=to_UTC("$date $cur->{stoptime}", '-0300') };
    if ($@) {
        warn "bad time string: $cur->{stoptime}";
        return undef;
    }
    t "...got $prog{stop}";

    if ($prog{stop} le $prog{start}) {
      t "... stop Date wrong: [$prog{stop}] ";
      @tempstop=split(" ",$prog{stop});
      $tempstop[0]=DateCalc($tempstop[0], '+ 1 day');
      $tempstop[0]=~ s/://g;
      $prog{stop}= $tempstop[0] . " " . $tempstop[1];
      t "...Fixed as $prog{stop}\n";
    } 
    $prog{desc}=[ [ $cur->{desc}, $LANG ] ] if defined $cur->{desc};
    $prog{credits}=$cur->{credits} if defined $cur->{credits};

    #    $prog{credits}=[ "actor","pepe badia" ];

    $prog{category}=[ [ $cur->{category}, $LANG ] ] if defined $cur->{category};
    $prog{length}=$cur->{length} if defined $cur->{length};
    $prog{date}=[ [ $cur->{date}, $LANG ] ] if defined $cur->{date};
    $prog{country}=[ [ $cur->{country}, $LANG ] ] if defined $cur->{country};
    $prog{rating}=[ [ $cur->{rating}, $LANG ] ] if defined $cur->{rating};
    return \%prog;

}
}

sub to_UTC {
	my ($mydate,$UTCDelta) = @_;
#	my @tempdate=split(" ",$UTCDelta);
	my ($DCDelta);
	t "In time [$mydate][$UTCDelta]";
#	if (defined $UTCDelta) {
	if ($UTCDelta =~ /^([+-])(\d{2})(\d{2})$/) {
#		$DCDelta = $1 . " ";
		if ($1 eq '+') {
			$DCDelta = "- ";
		} else {
			$DCDelta = "+ ";
		}
		$DCDelta .= ($2 . " hours") if $2 > 0;
		$DCDelta .= ($3 . " minutes") if $3 > 0;		
		if (length($DCDelta) > 2) {
			$mydate=DateCalc($mydate, $DCDelta);
			$mydate=~ s/://g;
		}
	}
	t " ... out time [$mydate][+0000]\n";	
	return utc_offset("$mydate", '+0000');
}


# Returns an array of programs for the specified day in the global variable now.
# All work is done by private get_programs_for function


sub get_program_data {
    my ($date,@ProgramWeek) = @_;
    my @nowarr=(
        UnixDate($date,"%Y"),
        UnixDate($date,"%m"),
        UnixDate($date,"%d"));
    my $weekday=Date_DayOfWeek($nowarr[1],$nowarr[2],$nowarr[0])-1;

#    return () if  $offset_left < 0 or $offset_top < 0 or $height < 0;

    return get_programs_for($ProgramWeek[$weekday]);
}

# get channel listing
sub get_channels {
    my $bar = new XMLTV::ProgressBar('getting list of channels', 1)  if not $opt_quiet;
    my %channels;
    
    # Get the available channels for the selected locality
    #   https://buscador.cablevisionfibertel.com.ar/index.aspx?cl=631
    #   
    my $page = fetch_url($urlRoot.'index.aspx?cl='.$location{'id'});  
    die $page if $page =~ /^Status:/;  
    #store_page($page);
    my $tree = get_tree($page); $page = undef;
    
    my $selectlist = $tree->look_down( '_tag' => 'select', 'id' => 'ChannelChoice' );
    die 'Cannot find channels list' if !$selectlist;
    my @selectoptions = $selectlist->look_down( '_tag' => 'option' );
		
		# we also need to map the web channel id to the tv channel id
		#    <input type="hidden" name="ctl00$ContGral$idsChanels" id="ContGral_idsChanels" 
		#         value="772,192,477,96,175,35,36,6,292,40,229,18,223,84,153,978,136,226,76,2292,77,45,33,15,37,22,19,366,11,164,17,178,9,57" />
		#    <input type="hidden" name="ctl00$ContGral$sintoniaChanels" id="ContGral_sintoniaChanels"
    #         value="7,8,9,10,11,12,13,14,15,16,17,18,19,20,20,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38" />
    #	
		my @webIds = split(/,/, $tree->look_down( '_tag' => 'input', 'id' => 'idsChanels' )->attr('value') );
		my @tvIds = split(/,/, $tree->look_down( '_tag' => 'input', 'id' => 'sintoniaChanels' )->attr('value') );	
		my %webIds;
    for (my $i=0; $i<scalar @webIds; $i++) {
			$webIds{$webIds[$i]} = $tvIds[$i];
		}
		
    foreach my $option (@selectoptions) {
      my $channel_id = $option->attr('value');
      next if $channel_id eq '-1' || $channel_id eq '0' || $channel_id eq '';
		
      my $channel_num = $webIds{$channel_id};
      my $channel_name = $option->as_text();    
      $channels{$channel_num}=$channel_name;
      my $coded_chan_name=encodeco("utf-8", $channel_name);
      #    print $coded_chan_name;
      push @ch_all, { 
                    'display-name' => [[ $coded_chan_name, $LANG ]],
                    'channel-num' => $channel_num,
                    'channel-id'  => $channel_id,
                    'id'=> "$channel_num.cablevision"
      };
    }

    $tree->delete;
    die "no channels could be found" if not keys %channels;
  
    #use Data::Dumper; print Dumper(\%channels);exit;
    #use Data::Dumper; print Dumper(@ch_all);exit;

    update $bar if not $opt_quiet;
    $bar->finish() if not $opt_quiet;
    return %channels;
}

# DEPRECATED
if (0){
# get channel listing
sub __get_channels {
    my $bar = new XMLTV::ProgressBar('getting list of channels', 1)
	if not $opt_quiet;
    my %channels;
    my ($locationid) = ($location{id});
    my $url=$urlRoot . "popUpGuiaCanales.php?companiaSeleccionada=" . $locationid;
    t $url;
    # Need to disable redirects to work
    $XMLTV::Get_nice::ua->max_redirect(0);
    my $tree = get_nice_tree $url; #($url, \&decode_utf8);
#    my @menus =  $tree->find("./div[\@class='grilla_tv']");
    my @lista = $tree->find_by_tag_name("_tag"=>"li");
    foreach my $elem (@lista) {
	my $tempdiv= $elem->look_down("_tag"=>"div");
        my $channel_name=trim($tempdiv->as_text);
        if (defined($tempdiv) && $tempdiv ne "") {
            my $opt = $elem->look_down("_tag"=>"a");
            if (not $opt->attr('onclick') eq "") {
		my ($channel_id) = ($opt->attr('onclick') =~ /.*canal=(\d+).*/i);
                my ($channel_num) = ($opt->attr('onclick') =~ /.*sintonia=(\d+).*/i);
                $channels{$channel_id}=$channel_name;
		my $coded_chan_name=encodeco("utf-8",$channel_name);
#		print $coded_chan_name;
                push @ch_all, { 
                              'display-name' => [[ $coded_chan_name, $LANG ],[$channel_num]],
                              'channel-num' => $channel_num  ,
#			      'channel-id'  => $channel_id,
                              'id'=> "$channel_id.cablevision" 
				};
            }
       }
    }
    die "no channels could be found" if not keys %channels;
    update $bar if not $opt_quiet;
    $bar->finish() if not $opt_quiet;
    return %channels;
}
}

# DEPRECATED
sub get_txt_elems {
    my ($tree) = @_;

    my @txt_elem;
    my @txt_cont = $tree->look_down(
                        sub { ($_[0]->descendants() eq 0  ) },       
			sub { defined($_[0]->attr ("_content") ) } );
	foreach my $txt (@txt_cont) {
        	my @children=$txt->content_list;
		if (defined($children[0])) {
                  for (my $tmp=$children[0]) {
			s/^\s+//;s/\s+$//;
			push @txt_elem, $_;
                      }
                }
	}
    return @txt_elem;
}

# DEPRECATED
# Bump a YYYYMMDD date by one.
sub nextday {
    my $d = shift;
    my $p = parse_date($d);
    my $n = DateCalc($p, '+ 1 day');
    return UnixDate($n, '%Q');
}

# DEPRECATED
sub GetWeekNumber {
    my $date=shift;
    my $today=UnixDate(parse_date('now'),"%Q"); 
    
    my @datearr=(
        UnixDate($date,"%Y"),
        UnixDate($date,"%m"),
        UnixDate($date,"%d"));

    my @todayarr=(
        UnixDate($today,"%Y"),
        UnixDate($today,"%m"),
        UnixDate($today,"%d"));
    my $weekdate=Date_WeekOfYear($datearr[1],$datearr[2],$datearr[0],1);
    my $weektoday=Date_WeekOfYear($todayarr[1],$todayarr[2],$todayarr[0],1);
    if ($datearr[0]==$todayarr[0]){
        return $weekdate - $weektoday; 
    }
    return $weekdate; 
}

# DEPRECATED
sub bump_start_day {
    my ($cur,$next) = @_;
    if (!defined($next)) {
	return undef;
    }
    my $start = UnixDate($cur->{time},'%H:%M');
    my $stop = UnixDate($next->{time},'%H:%M');
    if (Date_Cmp($start,$stop)>0) {
	return 1;
    } else {
	return 0;
    }
}
################################################################################
# 
# Because cablevision uses a grid made of DIV containers, we detect programs by 
# looking for coordinates
#
################################################################################

# DEPRECATED
# Get top most container
sub get_grid_offset_top {
    my ($tree) = @_;
    my $elem=$tree->look_down(
        '_tag', 'div',sub {
            defined $_[0]->attr('id') and $_[0]->attr('id')=~ /layerHora0/i
        });
    return -1 if not defined $elem;
    my ($top)=($elem->attr('style') =~ /top:\s*(\d+)\s*(px|)/i);
    return $top; 
    return 0;
}

# DEPRECATED
# Get left most offset for containers
sub get_grid_offset_left {
    my ($tree) = @_;
    my $elem=$tree->look_down(
        '_tag', 'div',sub {
            defined $_[0]->attr('id') and $_[0]->attr('id')=~ /layerHora0/i
        });
    return -1 if not defined $elem;
    my ($left)=($elem->attr('style') =~ /width:\s*(\d+)\s*(px|)/i);
    return $left;
}

# DEPRECATED
# Get default row height
sub get_grid_row_height {
    my ($tree) = @_;
    my $elem=$tree->look_down(
        '_tag', 'div',sub {
            defined $_[0]->attr('id') and $_[0]->attr('id')=~ /layerHora0/i
        });
    return -1 if not defined $elem;
    my ($height)=($elem->attr('style') =~ /height:\s*(\d+)\s*(px|)/i);
    return $height;
}

# DEPRECATED
# Get default row width
sub get_grid_row_width {
    my ($tree) = shift;
    my @rowDia=$tree->look_down(
        '_tag', 'td',sub {
            defined $_[0]->attr('class') && $_[0]->attr('class')=~ /layerDia/i
        });
    return $rowDia[int ($#rowDia/2)]->attr('width');
}

# DEPRECATED
sub parse_program {
		my ($celda) = @_; 
#channel, station, startday, celda)

# <a href="ficha.php?verFicha=224193" rel="#overlay_ficha" class="programaSemana" title="Parental Control" style="height:34px; top:-1px">

	my $title= encodeco("UTF-8",trim($celda->attr('title')));
	if (! (defined $title)) {
		$title= encodeco("UTF-8",trim($celda->as_text));         
	} 
        my ($top)=($celda->attr('style') =~ /top:\s*(-{0,1}\d+)\s*(px|)/i);
        my ($left)=($celda->attr('style') =~ /left:\s*(-{0,1}\d+)\s*(px|)/i);
        my ($height)=($celda->attr('style') =~ /height:\s*(-{0,1}\d+)\s*(px|)/i);
        my ($width)=($celda->attr('style') =~ /width:\s*(-{0,1}\d+)\s*(px|)/i);
	my $start=int (($top + 1) * (3600 / 68));

	my $mins=int($start/60);
	if ( $mins % 5 !=0 ){#Adjust to a multiple of 5 
        	$mins=($mins+5)-(($mins+5)%5); 
	}
	my $startT = UnixDate(DateCalc("00:00","+ $mins minutes"),"%H:%M");

	my $length = int(($height) * (3600 / 68));
	$mins=int($length/60);
	if ( $mins % 5 !=0 ){#Adjust to a multiple of 5 
        	$mins=($mins+5)-(($mins+5)%5); 
	}
	my $LengthT = UnixDate(DateCalc("00:00","+ $mins minutes"),"%H:%M");
	my $endT = UnixDate(DateCalc($startT,"+ $mins minutes"),"%H:%M");

        my %ret;

           %ret = (
                time =>         $startT,
                stoptime =>     $endT,
                title=>         $title
		);
	if ($opt_get_details) {
		my %TempDesc;
		my ($progindex)=($celda->attr('rev') =~ /ficha\.php\?verFicha.(\d+)/i);
		if (exists $Descriptions{$progindex}) {
			#original format
			#warn "\nfound index: $progindex with description [" . $Descriptions{$progindex} . "]\n\n";
			my $tempref = ($Descriptions{$progindex}) ;
			%TempDesc= %$tempref;
			foreach my $keyvalue (sort keys %TempDesc) {
				if (($keyvalue ne 'time') && ($keyvalue ne 'stoptime')) {
					$ret{$keyvalue} = $TempDesc{$keyvalue}
				}
			}
		}
		else {
			#original format
			eval {
				warn "\n" . $urlRoot . "ficha.php?verFicha=$progindex\n";
				my $ficha_tree=get_nice_tree($urlRoot . "ficha.php?verFicha=$progindex");
#			};
#			eval {
				my $Categoria = ($ficha_tree->look_down('_tag','h1'));
				if (defined $Categoria) {
					$Categoria = encodeco("UTF-8",trim($Categoria->as_text));
#					 $valor =~ s/, /,/g;

#                                        my @algo =split(',', $Categoria);
#                                        $Categoria = \@algo

				} else {
					$Categoria = "";
				}
#			};
#			eval {
				my $FichaBox=$ficha_tree->look_down(
			       		'_tag', 'div',sub {
					    defined $_[0]->attr('id') and
				            $_[0]->attr('id')=~ /ficha/i
				        });
#			};
#			eval {
				my $TituloEsp = ($ficha_tree->look_down('_tag','h2'));
				if (defined $TituloEsp) {
					$TituloEsp = encodeco("UTF-8",trim($TituloEsp->as_text));
				} else {
					$TituloEsp = $title;
				}
#			};
#			eval {
				my $SinopsisBox=$ficha_tree->look_down(
			       		'_tag', 'div',sub {
					    defined $_[0]->attr('class') and
				            $_[0]->attr('class')=~ /sinopsis/i
				        });
				my $sinopsis= ($SinopsisBox->look_down('_tag','p')) if (defined $SinopsisBox); 
				if (defined $sinopsis) {
					$sinopsis=encodeco("UTF-8",trim($sinopsis->as_text));
				} else {
					$sinopsis = "";
				}
	        		$ret{desc} = $sinopsis;
#			};
#			eval {			
	  		   	my %credits;
  				my @FichaTecnica = ($ficha_tree->look_down('_tag','li'));
				my $PropertyField;
				foreach my $Propiedad (@FichaTecnica){				
					if ((defined $Propiedad->attr('class')) and ($Propiedad->attr('class')=~ /itemf1/i)) {	
						$PropertyField=trim($Propiedad->as_text);
					} 
					else {
						my $valor;
						$valor=encodeco("UTF-8",trim($Propiedad->as_text));
						if ($PropertyField =~ m/Protagonista((s)?)/i ) {
							$valor =~ s/, /,/g;
							my @algo =split(',', $valor);
							$credits{actor} = \@algo
						}
						elsif ($PropertyField =~ m/Director((es)?)/i) { 
							$valor =~ s/, /,/g;
							my @algo =split(',', $valor);
							$credits{director} = \@algo
						}
						elsif ($PropertyField =~ m/Conductor((es)?)/i) { 
							$valor =~ s/, /,/g;
							my @algo =split(',', $valor);
							$credits{presenter} = \@algo
						}
						elsif ($PropertyField =~ m/G.nero/i) { 
							$ret{category} = $valor;
						}
						elsif ($PropertyField =~ m/(Duraci&oacute;n|Duración)/) { # html, utf-8 bytes, missing unicode chars
							$valor =~ /(\d*)\s(.*)(\n|\r)?/i;
							my $TempLength=$1;
							my $tempunit=$2;
							$tempunit=~ s/^\s//;
							$tempunit=~ s/\s$//;
#							$tempunit=~ s/minutos?/minutes/;
#							$tempunit=~ s/horas?/hours/;
#							$tempunit=~ s/segundos?/seconds/;
#							if ($tempunit=~ s/minutos?/i) { $TempLength = ($TempLength *60) }	
#							if ($tempunit=~ s/horas?/i) { $TempLength = ($TempLength *60) }	
							$ret{length} = ($TempLength *60);
						}
						elsif ($PropertyField =~ m/Pa.s/i) { 
							$ret{country} = $valor;
						}
						elsif ($PropertyField =~ m/(A&ntilde;o|Ano)/) { 
							$ret{date} = $valor;
						}
						elsif ($PropertyField eq 'Título original') { 
							$ret{title2} = $valor;
						}
						elsif ($PropertyField =~ m/Clasificaci.n/i) { 
							$ret{rating} = $valor;
						}
						else { 
							print STDERR "ignoring useless data ... [$PropertyField]\n";
						}
					$PropertyField = '';
					}
				}
				$ret{credits} = \%credits if %credits;
			};
		}	
		$Descriptions{$progindex}=\%ret;
	}

	return \%ret;

}

# DEPRECATED
################################################################################
# 
# Returns a hash with:
#   time
#   title
#   description
# 
################################################################################
sub get_programs_for {
    my ($ProgramDay)=@_;
    my @data;
#    my @row=$tree->look_down(
#        '_tag', 'div',sub {
#            $_[0]->attr('id')=~ /layer\d{1,2}/i and
#            $_[0]->attr('class')=~ /layerPrograma/i and 
#            defined $_[0]->attr('style') 
#        });



	my @Programs = $ProgramDay->find_by_tag_name("_tag"=>"a");       	           	    

#	print @Programs;
	foreach my $programa (@Programs) {
		push @data, parse_program ($programa)
	}


    return sort { Date_Cmp(ParseDate($a->{time}),ParseDate($b->{time})) } @data;
}

# DEPRECATED
sub encodeco {
 my($tempdummy,$temptexto)=@_;
#    print "$temptexto\n";
#    # decode the qouted-printable input
#    #$body = decode_qp( $body );
#    # decode to Perl's internal format
#    $temptexto = decode( 'iso-8859-1', $temptexto );
#    # encode to UTF-8
#    $temptexto = encode( 'utf-8', $temptexto );
#    print "$temptexto\n";

    return $temptexto;
}

# DEPRECATED
# Returns the time based on coordinates
sub get_start_time {
 my ($curr_top,$offset_top,$default_height)=@_;
    # default_height ===> 30 mins
    # curr_top - offset top ==> (curr_top-offset_top)*30/default_height
 my $mins=int (($curr_top-$offset_top)*30/$default_height);
    return "24:00" if $mins >= 1440;
    if ( $mins % 5 !=0 ){#Adjust to a multiple of 5 
        $mins=($mins+5)-(($mins+5)%5); 
    }
    return UnixDate(DateCalc("00:00","+ $mins minutes"),"%H:%M");
}

# Remove empty spaces from string
sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}

# DEPRECATED
# Remove HTML tagging from extended chars
sub Clean_amp {
    my ($texto)=@_;
#	Encode::from_to($texto, "iso-8859-1", "utf8");
        $texto=encodeco("utf-8",$texto);
#	my $textoold=$texto;
#	$texto =~ s/&amp;/&/g;
#	$texto =~ s/&acute;/á/g;
#	$texto =~ s/&aacute;/á/g;
#	$texto =~ s/&eacute;/é/g;
#	$texto =~ s/&iacute;/í/g;
#	$texto =~ s/&oacute;/ó/g;
#	$texto =~ s/&uacute;/ú/g;
#	$texto =~ s/&ntilde;/ñ/g;


   return $texto;
}

# DEPRECATED
# Adjusts stop time from a program to a time that doesn't overlaps considering a threshold
sub adjust_stoptime {
    my ($date,$prog_cur,$curstop,$nextstart,$ch_xmltv_id)=@_;
    if ( Date_Cmp($curstop,$nextstart) > 0 ){
        my $secscur=UnixDate($curstop,"%o");
        my $secsnext=UnixDate($nextstart,"%o");
        my $delta=$secscur-$secsnext;
        if ( $delta <= $allowed_overlap_tresh ){
            my $before=$prog_cur->{stoptime};
            $prog_cur->{stoptime}=$nextstart;
            my $after=$prog_cur->{stoptime};
            #warn "Correcting stop time for programme $prog_cur->{title} on $ch_xmltv_id.cablevision date $date:\n\tFrom $before to $after";
            $curstop=ParseDate("$date $prog_cur->{stoptime}");
        }
    }
    return $curstop;
}

# Select Location
sub select_location( ) {

    my $bar = new XMLTV::ProgressBar('getting list of Locations', 1)  if not $opt_quiet;

    my ($page, $data, $choice);
    
    # Get the available provinces
    #   https://buscador.cablevisionfibertel.com.ar/ProvinceSelector.aspx
    #
    $page = fetch_url($urlRoot.'ProvinceSelector.aspx');
    die $page if $page =~ /^Status:/;
    $data = get_json($page); $page = undef;
    my @provinces;
    foreach my $province (@{ $data->{'rows'} }) {
      push @provinces, $province->{'Provincia'};
    }
      
    $choice=ask_choice("Select your Province:",$provinces[0],@provinces);
    my $selectedprovince = $choice;
    
    
    # Get the available localities for the selected province
    #   https://buscador.cablevisionfibertel.com.ar/LocalitySelector.aspx?province=BUENOS%20AIRES
    #
    $page = fetch_url($urlRoot.'LocalitySelector.aspx?province='.$selectedprovince);
    die $page if $page =~ /^Status:/;
    $data = get_json($page); $page = undef;
    my %localities;
    foreach my $locality (@{ $data->{'rows'} }) {
      $localities{ $locality->{'Localidad'} } = $locality->{'Id'};
    }
    my @names;
    foreach (sort keys %localities) {
      push @names, $_;
    }
    
    $choice=ask_choice("Select your Locality:",$names[0],@names);
    my $selectedlocality = $choice;
    
    return ( id=> $localities{$choice}, name=>$choice );
}

# DEPRECATED
if (0){
# Select Location
sub __select_Location( ) {

    my $bar = new XMLTV::ProgressBar('getting list of Locations', 1)
	if not $opt_quiet;


    my $tree = get_nice_tree($urlRoot . "/popUpSeleccionZona.php?paisSeleccionado=cd");
    my @options=$tree->look_down(
        '_tag'=>'a', sub {
            defined $_[0]->attr('href') and
            ($_[0]->attr('href') =~ /CambiarZona/i)
        }
    );
    my %Locations;
	# Hardcoding Values for other companies
	$Locations{"* Telecentro *"} = 17;
	$Locations{"* DirecTV *"} = 16;
	$Locations{"* Capital Federal y GBA *"} = 3;

    foreach (@options){
	my $LocationID=$_->attr('href');
	$LocationID=~ s/\?cambiarzona=//i;
        $Locations{$_->as_text()}=$LocationID;
	
    }
    update $bar if not $opt_quiet;
    $bar->finish() if not $opt_quiet;

    my @names= sort keys %Locations;
    my $choice=ask_choice("Select your Locations:",$names[0],@names);
    return ( id=> $Locations{$choice}, name=>$choice );

}
}


# Initialise LWP
sub initialise_ua {
		my $cookies = HTTP::Cookies->new;
		#my $ua = LWP::UserAgent->new(keep_alive => 1);
		my $ua = LWP::UserAgent->new;
		# Cookies
		$ua->cookie_jar($cookies);
		# Define user agent type
		#$ua->agent('Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0');
		# Define timouts
		$ua->timeout(240);
		# Use proxy if set in http_proxy etc.
		$ua->env_proxy;
		#
		return $ua;
}

# Fetch a page
sub fetch_url ( $$$ ) {
		my $url = shift;
		my $method = shift;
		my $varhash = shift;
		my $res;
		if (defined $method && lc($method) eq 'post') {
			$res = $lwp->post($url, $varhash);
		} else {
			$res = $lwp->get($url);
		}
		if (!$res->is_success) {
				# error - format as a valid http status line
				return "Status: ".$res->status_line;
		}
		return $res->content;
}

# Parse a JSON response
sub get_json ( $ ) {
		my $page = shift;
		my $data = JSON::PP->new()->utf8(1)->decode($page);
		$page = undef;
		return $data;
}
		
# Parse HTML into a tree
sub get_tree ( $ ) {
	my $page = shift;
	my $tree = HTML::TreeBuilder->new();
  $tree->utf8_mode(1);
	$tree->parse($page) or die "Cannot parse content\n";
	$tree->eof;
	return $tree;
}

# Store a page (used for debugging)
sub store_page ( $ ) {
	my $data = shift;
	my $fn = 'grab'.time(); 
	my $fhok = open my $fh, '>', $fn or warning("Cannot open file $fn");  
	print $fh $data; 
	close $fh;
	return;
}

